{
    "launcher.py": {
        "content": "import sys\nfrom PyQt6.QtWidgets import (QApplication, QMainWindow, QVBoxLayout, \n                             QWidget, QLabel, QPushButton, QMessageBox)\nfrom PyQt6.QtCore import Qt\nfrom PyQt6.QtGui import QFont, QColor\n\n# --- Import your existing tool ---\n# This requires your previous script to be named 'workflow_organizer.py'\ntry:\n    from workflow_organizer import SmartWorkflowOrganizer\n    from script_library import ScriptLibrary\nexcept ImportError:\n    SmartWorkflowOrganizer = None\n    ScriptLibrary = None\n\nclass GenesisLauncher(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"Project Genesis - Hub\")\n        self.resize(800, 600)\n\n        # Apply the consistent Dark Theme\n        self.setStyleSheet(\"\"\"\n            QMainWindow { background-color: #1e1e1e; }\n            QLabel { color: #d4d4d4; font-family: 'Segoe UI'; }\n            QPushButton { \n                background-color: #252526; \n                color: white; \n                font-family: 'Segoe UI';\n                font-size: 16px;\n                border: 1px solid #3e3e42; \n                padding: 15px 30px; \n                border-radius: 8px;\n                text-align: left;\n            }\n            QPushButton:hover { \n                background-color: #007acc; \n                border: 1px solid #007acc;\n            }\n            QPushButton:disabled {\n                background-color: #1e1e1e;\n                color: #555555;\n                border: 1px dashed #3e3e42;\n            }\n        \"\"\")\n\n        # Central Layout\n        central_widget = QWidget()\n        self.setCentralWidget(central_widget)\n        layout = QVBoxLayout(central_widget)\n        layout.setSpacing(15)\n        layout.setContentsMargins(100, 60, 100, 60) # Generous margins for a clean look\n\n        # --- Header Section ---\n        title = QLabel(\"PROJECT GENESIS\")\n        title.setStyleSheet(\"font-size: 36px; font-weight: bold; color: white; letter-spacing: 2px;\")\n        title.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        layout.addWidget(title)\n\n        subtitle = QLabel(\"Select a module to begin\")\n        subtitle.setStyleSheet(\"font-size: 16px; color: #888888; margin-bottom: 20px;\")\n        subtitle.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        layout.addWidget(subtitle)\n\n        # --- Buttons Section ---\n        # 1. The Workflow Organizer (Active)\n        btn_workflow = QPushButton(\"\ud83d\udcc2   Workflow Organizer\")\n        btn_workflow.clicked.connect(self.launch_workflow)\n        layout.addWidget(btn_workflow)\n\n        # 2. Neural Assistant (Placeholder)\n        btn_ai = QPushButton(\"\ud83e\udd16   Neural Assistant (Coming Soon)\")\n        btn_ai.setEnabled(False) \n        layout.addWidget(btn_ai)\n\n        # 3. Script Library\n        btn_scripts = QPushButton(\"\ud83d\udcdc   Script Library\")\n        btn_scripts.clicked.connect(self.launch_library) # Connect function\n        layout.addWidget(btn_scripts)\n\n        layout.addStretch()\n\n        # Footer\n        footer = QLabel(\"System v1.0 | Ready\")\n        footer.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        footer.setStyleSheet(\"color: #444444; font-size: 12px;\")\n        layout.addWidget(footer)\n\n    def launch_workflow(self):\n        if SmartWorkflowOrganizer:\n            # Create the tool window\n            self.tool_window = SmartWorkflowOrganizer()\n            self.tool_window.show()\n            # Close the menu (or use self.hide() if you want to keep it running)\n            self.close()\n        else:\n            QMessageBox.critical(self, \"Error\", \"Could not find 'workflow_organizer.py'.\\nMake sure both files are in the same folder.\")\n\n    def launch_library(self):\n        if ScriptLibrary:\n            self.lib_window = ScriptLibrary()\n            self.lib_window.show()\n            self.close()\n        else:\n            QMessageBox.critical(self, \"Error\", \"Could not find 'script_library.py'.\")\n\n# --- Entry Point ---\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    window = GenesisLauncher()\n    window.show()\n    sys.exit(app.exec())",
        "language": "Python"
    },
    "script_library.py": {
        "content": "import sys\nimport os\nimport json\nfrom PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, \n                             QHBoxLayout, QListWidget, QPlainTextEdit, QLabel, \n                             QPushButton, QInputDialog, QMessageBox, QSplitter)\nfrom PyQt6.QtGui import QColor, QFont, QIcon\nfrom PyQt6.QtCore import Qt\n\nclass ScriptLibrary(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"Project Genesis - Script Library\")\n        self.resize(1000, 700)\n        \n        self.save_file = \"genesis_scripts.json\"\n        self.scripts_data = {} # { \"Script Name\": \"print('hello')\" }\n        self.current_script = None\n\n        # --- UI STYLING (Matching the DAG) ---\n        self.setStyleSheet(\"\"\"\n            QMainWindow { background-color: #1e1e1e; }\n            QWidget { color: #d4d4d4; font-family: 'Segoe UI'; font-size: 14px; }\n            \n            /* The List Sidebar */\n            QListWidget {\n                background-color: #252526;\n                border: 1px solid #3e3e42;\n                border-radius: 4px;\n                padding: 5px;\n                outline: none;\n            }\n            QListWidget::item { padding: 8px; border-radius: 4px; }\n            QListWidget::item:selected { background-color: #37373d; color: white; }\n            QListWidget::item:hover { background-color: #2a2d2e; }\n\n            /* The Code Editor */\n            QPlainTextEdit {\n                background-color: #1e1e1e;\n                border: 1px solid #3e3e42;\n                border-radius: 4px;\n                font-family: 'Consolas', 'Courier New', monospace;\n                font-size: 13px;\n                color: #dcdcaa; /* VS Code Yellow-ish for text */\n                padding: 10px;\n            }\n\n            /* Buttons */\n            QPushButton { \n                background-color: #007acc; color: white; border: none; \n                padding: 6px 15px; border-radius: 4px;\n            }\n            QPushButton:hover { background-color: #0062a3; }\n            QPushButton#DeleteBtn { background-color: #d73a49; }\n            QPushButton#DeleteBtn:hover { background-color: #a32a35; }\n            QPushButton#NavBtn { background-color: #3e3e42; border: 1px solid #555; }\n            QPushButton#NavBtn:hover { background-color: #505055; }\n        \"\"\")\n\n        # --- Main Layout ---\n        central = QWidget()\n        self.setCentralWidget(central)\n        main_layout = QVBoxLayout(central)\n\n        # 1. Toolbar\n        toolbar = QHBoxLayout()\n        \n        self.btn_home = QPushButton(\"\ud83c\udfe0 Menu\")\n        self.btn_home.setObjectName(\"NavBtn\")\n        self.btn_home.clicked.connect(self.return_to_launcher)\n        toolbar.addWidget(self.btn_home)\n\n        toolbar.addSpacing(15)\n        lbl_title = QLabel(\"Script Treasury\")\n        lbl_title.setStyleSheet(\"font-weight: bold; font-size: 16px;\")\n        toolbar.addWidget(lbl_title)\n\n        toolbar.addStretch()\n\n        self.btn_new = QPushButton(\"+ New Script\")\n        self.btn_new.clicked.connect(self.new_script)\n        toolbar.addWidget(self.btn_new)\n\n        self.btn_save = QPushButton(\"\ud83d\udcbe Save Changes\")\n        self.btn_save.clicked.connect(self.save_current_script)\n        toolbar.addWidget(self.btn_save)\n\n        self.btn_copy = QPushButton(\"\ud83d\udccb Copy Code\")\n        self.btn_copy.clicked.connect(self.copy_to_clipboard)\n        self.btn_copy.setStyleSheet(\"background-color: #2da44e;\") # Github Green\n        toolbar.addWidget(self.btn_copy)\n\n        self.btn_delete = QPushButton(\"\ud83d\uddd1\ufe0f Delete\")\n        self.btn_delete.setObjectName(\"DeleteBtn\")\n        self.btn_delete.clicked.connect(self.delete_script)\n        toolbar.addWidget(self.btn_delete)\n\n        main_layout.addLayout(toolbar)\n\n        # 2. Splitter (Sidebar vs Editor)\n        splitter = QSplitter(Qt.Orientation.Horizontal)\n        \n        # Left: List\n        self.script_list = QListWidget()\n        self.script_list.setFixedWidth(250)\n        self.script_list.currentItemChanged.connect(self.load_selected_script)\n        splitter.addWidget(self.script_list)\n\n        # Right: Editor\n        self.editor = QPlainTextEdit()\n        self.editor.setPlaceholderText(\"Select or create a script to begin writing...\")\n        splitter.addWidget(self.editor)\n\n        splitter.setCollapsible(0, False)\n        splitter.setCollapsible(1, False)\n        main_layout.addWidget(splitter)\n\n        # Load Data\n        self.load_data()\n\n    # --- LOGIC ---\n    def load_data(self):\n        \"\"\"Loads scripts from JSON.\"\"\"\n        if os.path.exists(self.save_file):\n            try:\n                with open(self.save_file, 'r') as f:\n                    self.scripts_data = json.load(f)\n            except:\n                self.scripts_data = {}\n        \n        self.script_list.clear()\n        self.script_list.addItems(sorted(self.scripts_data.keys()))\n\n    def save_data(self):\n        \"\"\"Writes data to JSON.\"\"\"\n        try:\n            with open(self.save_file, 'w') as f:\n                json.dump(self.scripts_data, f, indent=4)\n        except Exception as e:\n            print(f\"Save error: {e}\")\n\n    def new_script(self):\n        name, ok = QInputDialog.getText(self, \"New Script\", \"Script Name:\")\n        if ok and name:\n            if name in self.scripts_data:\n                QMessageBox.warning(self, \"Error\", \"Script already exists!\")\n                return\n            \n            # Save current before switching\n            if self.current_script:\n                self.save_current_script()\n\n            # Create new\n            self.scripts_data[name] = \"\" # Empty content\n            self.script_list.addItem(name)\n            self.script_list.setCurrentRow(self.script_list.count() - 1)\n            self.save_data()\n\n    def load_selected_script(self, current, previous):\n        \"\"\"Called when user clicks a list item.\"\"\"\n        # 1. Save previous if exists\n        if previous:\n            prev_name = previous.text()\n            if prev_name in self.scripts_data:\n                self.scripts_data[prev_name] = self.editor.toPlainText()\n        \n        # 2. Load new\n        if current:\n            self.current_script = current.text()\n            content = self.scripts_data.get(self.current_script, \"\")\n            self.editor.setPlainText(content)\n        else:\n            self.current_script = None\n            self.editor.clear()\n\n    def save_current_script(self):\n        if self.current_script:\n            self.scripts_data[self.current_script] = self.editor.toPlainText()\n            self.save_data()\n            # Visual feedback in status bar (optional) could go here\n\n    def delete_script(self):\n        if not self.current_script: return\n        \n        confirm = QMessageBox.question(self, \"Delete\", f\"Delete '{self.current_script}'?\", \n                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)\n        if confirm == QMessageBox.StandardButton.Yes:\n            del self.scripts_data[self.current_script]\n            self.save_data()\n            self.load_data() # Refresh list\n            self.editor.clear()\n\n    def copy_to_clipboard(self):\n        cb = QApplication.clipboard()\n        cb.setText(self.editor.toPlainText())\n\n    def return_to_launcher(self):\n        self.save_current_script() # Auto-save\n        try:\n            from launcher import GenesisLauncher\n            self.launcher = GenesisLauncher()\n            self.launcher.show()\n            self.close()\n        except ImportError:\n            QMessageBox.warning(self, \"Error\", \"launcher.py not found.\")\n\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    window = ScriptLibrary()\n    window.show()\n    sys.exit(app.exec())",
        "language": "Plain Text"
    },
    "workflow_organizer.py": {
        "content": "import sys\nimport os\nimport ctypes\nimport json\nimport uuid \nimport math\n\n# --- Safe Import Logic ---\ndef show_error_and_exit(missing_module):\n    \"\"\"Displays a native error dialog and exits.\"\"\"\n    message = (f\"Error: Could not import '{missing_module}'.\\n\\n\"\n               \"Please ensure you are running this script within the Python Virtual Environment.\\n\"\n               \"Try running: .venv\\\\Scripts\\\\python.exe workflow_organizer.py\")\n    title = \"Dependency Missing\"\n    ctypes.windll.user32.MessageBoxW(0, message, title, 0x10 | 0x0)\n    sys.exit(1)\n\ntry:\n    from PyQt6.QtWidgets import (QApplication, QMainWindow, QGraphicsView, \n                                 QGraphicsScene, QVBoxLayout, QHBoxLayout, QWidget, QLabel, \n                                 QGraphicsRectItem, QGraphicsItem, QGraphicsTextItem, \n                                 QPushButton, QGraphicsLineItem, QMenu, QFileDialog, \n                                 QInputDialog, QComboBox, QMessageBox)\n    from PyQt6.QtGui import QColor, QFont, QPen, QBrush, QAction, QDesktopServices, QPainter, QCursor, QTransform\n    from PyQt6.QtCore import Qt, QTimer, QLineF, QUrl, QPointF, QRectF\nexcept ImportError:\n    show_error_and_exit(\"PyQt6\")\n\n# --- 1. Custom Graphics View ---\nclass SmartView(QGraphicsView):\n    def __init__(self, scene, main_window_ref):\n        super().__init__(scene)\n        self.main_window = main_window_ref \n        self.setRenderHint(QPainter.RenderHint.Antialiasing)\n        self.setDragMode(QGraphicsView.DragMode.RubberBandDrag) \n        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)\n        self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)\n        \n        self._is_panning = False\n        self._pan_start = QPointF(0, 0)\n        \n        self._current_zoom = 1.0\n        self._min_zoom = 0.5  \n        self._max_zoom = 2.0 \n\n        self.grid_color_light = QColor(\"#2d2d30\")\n        self.grid_color_dark = QColor(\"#1e1e1e\")\n        self.setBackgroundBrush(self.grid_color_dark)\n\n    def drawBackground(self, painter, rect):\n        super().drawBackground(painter, rect)\n        \n        grid_size = 50\n        left = int(rect.left()) - (int(rect.left()) % grid_size)\n        top = int(rect.top()) - (int(rect.top()) % grid_size)\n        \n        lines = []\n        right = int(rect.right())\n        bottom = int(rect.bottom())\n        \n        for x in range(left, right, grid_size):\n            lines.append(QLineF(x, rect.top(), x, rect.bottom()))\n        \n        for y in range(top, bottom, grid_size):\n            lines.append(QLineF(rect.left(), y, rect.right(), y))\n\n        pen = QPen(self.grid_color_light)\n        pen.setWidth(1)\n        painter.setPen(pen)\n        painter.drawLines(lines)\n\n    def keyPressEvent(self, event):\n        focus_item = self.scene().focusItem()\n        if isinstance(focus_item, QGraphicsTextItem):\n            super().keyPressEvent(event)\n            return\n\n        if event.key() == Qt.Key.Key_Space:\n            self.main_window.focus_camera_on_nodes()\n        else:\n            super().keyPressEvent(event)\n\n    def wheelEvent(self, event):\n        if event.modifiers() & Qt.KeyboardModifier.ShiftModifier:\n            zoom_in_factor = 1.1\n            zoom_out_factor = 1 / zoom_in_factor\n\n            if event.angleDelta().y() > 0:\n                zoom_factor = zoom_in_factor\n            else:\n                zoom_factor = zoom_out_factor\n            \n            new_zoom = self._current_zoom * zoom_factor\n\n            if self._min_zoom <= new_zoom <= self._max_zoom:\n                self.scale(zoom_factor, zoom_factor)\n                self._current_zoom = new_zoom\n        else:\n            super().wheelEvent(event)\n\n    def mousePressEvent(self, event):\n        if event.button() == Qt.MouseButton.MiddleButton:\n            self._is_panning = True\n            self._pan_start = event.position()\n            self.setCursor(Qt.CursorShape.ClosedHandCursor)\n            event.accept()\n        else:\n            super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event):\n        if self._is_panning:\n            delta = event.position() - self._pan_start\n            self._pan_start = event.position()\n            \n            self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() - int(delta.x()))\n            self.verticalScrollBar().setValue(self.verticalScrollBar().value() - int(delta.y()))\n            event.accept()\n        else:\n            super().mouseMoveEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        if event.button() == Qt.MouseButton.MiddleButton:\n            self._is_panning = False\n            self.setCursor(Qt.CursorShape.ArrowCursor)\n            event.accept()\n        else:\n            super().mouseReleaseEvent(event)\n\n# --- 2. The Connection Line Class ---\nclass ConnectionLine(QGraphicsLineItem):\n    def __init__(self, start_node, end_node):\n        super().__init__()\n        self.start_node = start_node\n        self.end_node = end_node\n        \n        pen = QPen(QColor(\"#666666\"))\n        pen.setWidth(2)\n        pen.setStyle(Qt.PenStyle.DashLine) \n        self.setPen(pen)\n        self.setZValue(-1) \n        \n        self.update_position()\n\n    def update_position(self):\n        if not self.start_node.scene() or not self.end_node.scene():\n            return\n\n        start_pos = self.start_node.scenePos()\n        end_pos = self.end_node.scenePos()\n        \n        offset_x = 100 \n        offset_y = 40\n        source_point = start_pos + QPointF(offset_x, offset_y)\n        dest_point = end_pos + QPointF(offset_x, offset_y)\n        self.setLine(QLineF(source_point, dest_point))\n\n# --- 3. The Smart Node Class ---\nclass SmartNode(QGraphicsRectItem):\n    def __init__(self, name, x, y, main_window_ref, watch_path=None, node_id=None):\n        super().__init__(0, 0, 200, 80) \n        \n        self.main_window = main_window_ref \n        self.name = name\n        self.id = node_id if node_id else str(uuid.uuid4()) \n        \n        self.watch_path = watch_path\n        self.attachment_type = \"None\" \n        self.connected_lines = [] \n        self.custom_color = None \n        self.is_completed = False \n        self.is_start_node = False \n        \n        self.setPos(x, y)\n\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)\n        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges)\n\n        # Default Pens\n        self.pen_default = QPen(Qt.PenStyle.NoPen)\n        # Gold Pen for Start Node\n        self.pen_start = QPen(QColor(\"#FFD700\")) \n        self.pen_start.setWidth(3)\n\n        self.brush_pending = QBrush(QColor(\"#3e3e42\")) \n        self.brush_done = QBrush(QColor(\"#2da44e\"))   \n        self.brush_link = QBrush(QColor(\"#007acc\"))   \n        self.brush_disabled = QBrush(QColor(\"#252526\")) \n        \n        self.setBrush(self.brush_pending)\n        self.setPen(self.pen_default)\n\n        # Title\n        self.text_item = QGraphicsTextItem(name, self)\n        self.set_text_style(completed=False)\n        self.text_item.setPos(10, 15)\n        self.text_item.setTextInteractionFlags(Qt.TextInteractionFlag.TextEditorInteraction)\n        self.text_item.document().contentsChanged.connect(self.update_name_from_text)\n\n        # Type Indicator\n        self.type_item = QGraphicsTextItem(\"\", self)\n        self.type_item.setDefaultTextColor(QColor(\"#aaaaaa\"))\n        self.type_item.setFont(QFont(\"Segoe UI\", 8))\n        self.type_item.setPos(10, 45)\n\n    def set_text_style(self, completed=False):\n        font = QFont(\"Segoe UI\", 11, QFont.Weight.Bold)\n        if completed:\n            font.setStrikeOut(True)\n            self.text_item.setDefaultTextColor(QColor(\"#B0B0B0\"))\n        else:\n            font.setStrikeOut(False)\n            self.text_item.setDefaultTextColor(Qt.GlobalColor.white)\n        self.text_item.setFont(font)\n\n    def update_name_from_text(self):\n        self.name = self.text_item.toPlainText()\n\n    def contextMenuEvent(self, event):\n        menu = QMenu()\n        \n        # Start Node Toggle\n        if self.is_start_node:\n            action_start = menu.addAction(\"\ud83d\udeab Unset Start Node\")\n        else:\n            action_start = menu.addAction(\"\ud83c\udfc1 Set as Start Node\")\n        action_start.triggered.connect(self.toggle_start_node)\n\n        menu.addSeparator()\n\n        if self.is_completed:\n            action_done = menu.addAction(\"Incomplete Task\")\n        else:\n            action_done = menu.addAction(\"\u2705 Mark as Done\")\n        action_done.triggered.connect(self.toggle_complete)\n        \n        menu.addSeparator()\n\n        color_menu = menu.addMenu(\"\ud83c\udfa8 Set Color\")\n        colors = {\"Default\": None, \"Urgent (Red)\": \"#d73a49\", \"Work (Blue)\": \"#0366d6\", \n                  \"Idea (Purple)\": \"#6f42c1\", \"Warning (Orange)\": \"#d19a66\"}\n        for name, hex_code in colors.items():\n            action = color_menu.addAction(name)\n            action.triggered.connect(lambda checked, h=hex_code: self.set_custom_color(h))\n\n        menu.addSeparator()\n\n        action_file = menu.addAction(\"\ud83d\udcc4 Attach File\")\n        action_file.triggered.connect(self.browse_file)\n        action_folder = menu.addAction(\"\ud83d\udcc1 Attach Folder\")\n        action_folder.triggered.connect(self.browse_folder)\n        action_link = menu.addAction(\"\ud83c\udf10 Attach Web Link\")\n        action_link.triggered.connect(self.input_link)\n        \n        if self.watch_path:\n            menu.addSeparator()\n            action_open = menu.addAction(\"\ud83d\ude80 Open Attachment\")\n            action_open.triggered.connect(self.open_attachment)\n            action_remove = menu.addAction(\"\u274c Remove Attachment\")\n            action_remove.triggered.connect(self.remove_attachment)\n\n        menu.addSeparator()\n        action_delete = menu.addAction(\"\ud83d\uddd1\ufe0f Delete Node\")\n        action_delete.triggered.connect(self.delete_self)\n\n        menu.exec(event.screenPos())\n\n    def toggle_start_node(self):\n        self.is_start_node = not self.is_start_node\n        self.check_status() \n\n    def delete_self(self):\n        self.main_window.delete_node(self)\n\n    def toggle_complete(self):\n        self.is_completed = not self.is_completed\n        self.set_text_style(self.is_completed)\n        self.check_status()\n        self.main_window.update_progress()\n\n    def set_custom_color(self, color_hex):\n        self.custom_color = color_hex\n        self.check_status()\n\n    def browse_file(self):\n        path, _ = QFileDialog.getOpenFileName(None, \"Select File\")\n        if path: self.set_attachment(path, \"File\")\n\n    def browse_folder(self):\n        path = QFileDialog.getExistingDirectory(None, \"Select Folder\")\n        if path: self.set_attachment(path, \"Folder\")\n\n    def input_link(self):\n        text, ok = QInputDialog.getText(None, \"Attach Link\", \"Enter URL:\")\n        if ok and text: self.set_attachment(text, \"Link\")\n\n    def remove_attachment(self):\n        self.watch_path = None\n        self.attachment_type = \"None\"\n        self.check_status()\n\n    def set_attachment(self, path, type_name):\n        self.watch_path = path\n        self.attachment_type = type_name\n        self.check_status() \n\n    def open_attachment(self):\n        if self.watch_path:\n            QDesktopServices.openUrl(QUrl.fromLocalFile(self.watch_path) if self.attachment_type != \"Link\" else QUrl(self.watch_path))\n\n    def itemChange(self, change, value):\n        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange:\n            for line in self.connected_lines:\n                line.update_position()\n            \n            # --- CRASH FIX ---\n            # Removed the ensureVisible call. \n            # It creates infinite recursion loops during drag events.\n            # Stability is prioritized over auto-scroll.\n            \n        return super().itemChange(change, value)\n\n    def check_status(self):\n        if self.attachment_type == \"None\":\n            self.type_item.setPlainText(\"\")\n        else:\n            display_text = self.watch_path if len(self.watch_path) < 25 else \"...\" + self.watch_path[-22:]\n            self.type_item.setPlainText(f\"[{self.attachment_type}] {display_text}\")\n\n        # Border Logic\n        if self.is_start_node:\n            self.setPen(self.pen_start)\n        else:\n            self.setPen(self.pen_default)\n\n        # Color/Opacity Logic\n        if self.is_completed:\n            self.setBrush(self.brush_disabled)\n            self.setOpacity(0.9) \n            self.setToolTip(\"Status: Completed\")\n            return\n        \n        self.setOpacity(1.0) \n\n        if self.custom_color:\n            self.setBrush(QBrush(QColor(self.custom_color)))\n            self.setToolTip(\"Status: Custom Color\")\n        elif self.attachment_type == \"Link\":\n            self.setBrush(self.brush_link)\n            self.setToolTip(f\"Link: {self.watch_path}\")\n        elif self.watch_path and os.path.exists(self.watch_path):\n            self.setBrush(self.brush_done)\n            self.setToolTip(f\"Ready: {self.watch_path}\")\n        else:\n            self.setBrush(self.brush_pending)\n            self.setToolTip(f\"Pending: {self.watch_path}\")\n\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"x\": self.x(),\n            \"y\": self.y(),\n            \"watch_path\": self.watch_path,\n            \"attachment_type\": self.attachment_type,\n            \"custom_color\": self.custom_color,\n            \"is_completed\": self.is_completed,\n            \"is_start_node\": self.is_start_node \n        }\n\n# --- 4. The Main Window ---\nclass SmartWorkflowOrganizer(QMainWindow):\n    def __init__(self):\n        super().__init__()\n\n        self.setWindowTitle(\"Project Genesis - Workflow Organizer\")\n        self.resize(1200, 800) \n\n        self.save_file_path = \"genesis_data.json\"\n        self.pipelines_data = {} \n        self.current_pipeline_name = \"Default Project\"\n\n        self.setStyleSheet(\"\"\"\n            QMainWindow { background-color: #1e1e1e; }\n            QGraphicsView { background-color: #1e1e1e; border: 1px solid #3e3e42;}\n            QLabel { color: #d4d4d4; font-family: 'Segoe UI'; }\n            QPushButton { \n                background-color: #007acc; color: white; border: none; \n                padding: 6px 12px; font-size: 13px; border-radius: 4px;\n            }\n            QPushButton:hover { background-color: #0062a3; }\n            QComboBox { \n                background-color: #3e3e42; color: white; padding: 5px; border-radius: 4px; min-width: 150px;\n            }\n            QMenu { background-color: #252526; color: white; border: 1px solid #3e3e42; }\n            QMenu::item:selected { background-color: #007acc; }\n        \"\"\")\n\n        central_widget = QWidget()\n        self.setCentralWidget(central_widget)\n        main_layout = QVBoxLayout(central_widget)\n        \n        # --- Toolbar ---\n        toolbar_layout = QHBoxLayout()\n        \n        self.btn_home = QPushButton(\"\ud83c\udfe0 Menu\")\n        self.btn_home.setFixedWidth(80)\n        self.btn_home.setStyleSheet(\"background-color: #3e3e42; border: 1px solid #555;\")\n        self.btn_home.clicked.connect(self.return_to_launcher)\n        toolbar_layout.addWidget(self.btn_home)\n\n        toolbar_layout.addSpacing(10)\n\n        lbl_pipe = QLabel(\"Project:\")\n        lbl_pipe.setFont(QFont(\"Segoe UI\", 12, QFont.Weight.Bold))\n        toolbar_layout.addWidget(lbl_pipe)\n\n        self.combo_pipelines = QComboBox()\n        self.combo_pipelines.currentIndexChanged.connect(self.change_pipeline)\n        toolbar_layout.addWidget(self.combo_pipelines)\n\n        self.btn_proj_opt = QPushButton(\"\u2699\ufe0f\")\n        self.btn_proj_opt.setFixedWidth(40)\n        self.btn_proj_opt.clicked.connect(self.show_project_options)\n        toolbar_layout.addWidget(self.btn_proj_opt)\n\n        self.btn_new_pipe = QPushButton(\"+ New\")\n        self.btn_new_pipe.clicked.connect(self.create_new_pipeline)\n        toolbar_layout.addWidget(self.btn_new_pipe)\n\n        toolbar_layout.addSpacing(20)\n        self.progress_label = QLabel(\"0 / 0 Completed\")\n        self.progress_label.setStyleSheet(\"font-size: 14px; font-weight: bold; color: white;\")\n        toolbar_layout.addWidget(self.progress_label)\n\n        toolbar_layout.addStretch() \n        \n        self.btn_add = QPushButton(\"+ Add Node\")\n        self.btn_add.clicked.connect(self.add_new_node_center)\n        toolbar_layout.addWidget(self.btn_add)\n\n        self.btn_connect = QPushButton(\"Connect Selected\")\n        self.btn_connect.clicked.connect(self.connect_selected_nodes)\n        toolbar_layout.addWidget(self.btn_connect)\n        \n        main_layout.addLayout(toolbar_layout)\n\n        # Scene & Custom View\n        self.scene = QGraphicsScene()\n        self.scene.setSceneRect(0, 0, 10000, 10000) \n        \n        self.view = SmartView(self.scene, self)\n        main_layout.addWidget(self.view)\n\n        self.nodes = [] \n        self.lines = []\n\n        self.load_from_disk()\n        \n        self.timer = QTimer()\n        self.timer.timeout.connect(self.update_all_nodes)\n        self.timer.start(2000) \n\n    # --- NAVIGATION LOGIC ---\n    def return_to_launcher(self):\n        self.save_current_pipeline_to_memory()\n        self.save_to_disk()\n        try:\n            from launcher import GenesisLauncher\n            self.launcher = GenesisLauncher()\n            self.launcher.show()\n            self.close() \n        except ImportError:\n            QMessageBox.warning(self, \"Navigation Error\", \"Could not find 'launcher.py'.\\nEnsure it is in the same directory.\")\n\n    # --- FOCUS LOGIC ---\n    def focus_camera_on_nodes(self):\n        if not self.nodes:\n            return\n        min_x = min(n.x() for n in self.nodes)\n        max_x = max(n.x() + 200 for n in self.nodes)\n        min_y = min(n.y() for n in self.nodes)\n        max_y = max(n.y() + 80 for n in self.nodes)\n        center_x = (min_x + max_x) / 2\n        center_y = (min_y + max_y) / 2\n        self.view.centerOn(center_x, center_y)\n\n    # --- NODE MANAGEMENT ---\n    def delete_node(self, node):\n        for line in node.connected_lines:\n            if line in self.lines:\n                self.scene.removeItem(line)\n                self.lines.remove(line)\n        if node in self.nodes:\n            self.nodes.remove(node)\n        self.scene.removeItem(node)\n        self.update_progress()\n\n    def update_progress(self):\n        total = len(self.nodes)\n        completed = sum(1 for n in self.nodes if n.is_completed)\n        self.progress_label.setText(f\"{completed} / {total} Completed\")\n\n    # --- PROJECT MANAGEMENT ---\n    def show_project_options(self):\n        menu = QMenu()\n        act_rename = menu.addAction(\"Rename Project\")\n        act_rename.triggered.connect(self.rename_project)\n        act_delete = menu.addAction(\"Delete Project\")\n        act_delete.triggered.connect(self.delete_project)\n        menu.exec(self.btn_proj_opt.mapToGlobal(self.btn_proj_opt.rect().bottomLeft()))\n\n    def rename_project(self):\n        old_name = self.current_pipeline_name\n        new_name, ok = QInputDialog.getText(self, \"Rename Project\", \"New Name:\", text=old_name)\n        if ok and new_name and new_name != old_name:\n            if new_name in self.pipelines_data:\n                QMessageBox.warning(self, \"Error\", \"Name already exists!\")\n                return\n            \n            self.save_current_pipeline_to_memory()\n            self.pipelines_data[new_name] = self.pipelines_data.pop(old_name)\n            self.current_pipeline_name = new_name\n            \n            self.combo_pipelines.blockSignals(True)\n            idx = self.combo_pipelines.findText(old_name)\n            self.combo_pipelines.setItemText(idx, new_name)\n            self.combo_pipelines.blockSignals(False)\n\n    def delete_project(self):\n        if len(self.pipelines_data) <= 1:\n            QMessageBox.warning(self, \"Error\", \"Cannot delete the only project.\")\n            return\n\n        reply = QMessageBox.question(self, \"Confirm Delete\", \n                                     f\"Are you sure you want to delete '{self.current_pipeline_name}'?\",\n                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)\n        \n        if reply == QMessageBox.StandardButton.Yes:\n            del self.pipelines_data[self.current_pipeline_name]\n            self.current_pipeline_name = list(self.pipelines_data.keys())[0]\n            \n            self.combo_pipelines.blockSignals(True)\n            self.combo_pipelines.clear()\n            self.combo_pipelines.addItems(list(self.pipelines_data.keys()))\n            self.combo_pipelines.setCurrentText(self.current_pipeline_name)\n            self.combo_pipelines.blockSignals(False)\n            \n            self.load_pipeline_to_scene(self.current_pipeline_name)\n\n    # --- SAVE / LOAD ---\n    def closeEvent(self, event):\n        self.save_current_pipeline_to_memory()\n        self.save_to_disk()\n        super().closeEvent(event)\n\n    def save_current_pipeline_to_memory(self):\n        node_data = [n.to_dict() for n in self.nodes]\n        edge_data = []\n        for line in self.lines:\n            if line.start_node in self.nodes and line.end_node in self.nodes:\n                edge_data.append({\n                    \"start\": line.start_node.id,\n                    \"end\": line.end_node.id\n                })\n        \n        self.pipelines_data[self.current_pipeline_name] = {\n            \"nodes\": node_data,\n            \"edges\": edge_data\n        }\n\n    # --- ATOMIC SAFE SAVE ---\n    def save_to_disk(self):\n        \"\"\"Writes to a temporary file first to prevent corruption.\"\"\"\n        temp_file = self.save_file_path + \".tmp\"\n        try:\n            with open(temp_file, 'w') as f:\n                json.dump(self.pipelines_data, f, indent=4)\n            \n            # If successful, replace the old file\n            if os.path.exists(self.save_file_path):\n                os.remove(self.save_file_path)\n            os.rename(temp_file, self.save_file_path)\n            print(\"Saved successfully.\")\n        except Exception as e:\n            print(f\"Save Failed: {e}\")\n\n    def load_from_disk(self):\n        if os.path.exists(self.save_file_path):\n            try:\n                with open(self.save_file_path, 'r') as f:\n                    self.pipelines_data = json.load(f)\n            except Exception:\n                self.pipelines_data = {\"Default Project\": {\"nodes\": [], \"edges\": []}}\n        else:\n            self.pipelines_data = {\"Default Project\": {\"nodes\": [], \"edges\": []}}\n\n        self.combo_pipelines.blockSignals(True) \n        self.combo_pipelines.clear()\n        self.combo_pipelines.addItems(list(self.pipelines_data.keys()))\n        self.combo_pipelines.blockSignals(False)\n\n        if self.pipelines_data:\n            self.current_pipeline_name = list(self.pipelines_data.keys())[0]\n            self.load_pipeline_to_scene(self.current_pipeline_name)\n\n    def load_pipeline_to_scene(self, pipeline_name):\n        self.scene.clear()\n        self.nodes = []\n        self.lines = []\n        \n        data = self.pipelines_data.get(pipeline_name, {\"nodes\": [], \"edges\": []})\n        \n        node_map = {} \n        for n_data in data[\"nodes\"]:\n            node = SmartNode(n_data[\"name\"], n_data[\"x\"], n_data[\"y\"], self, \n                             watch_path=n_data.get(\"watch_path\"), node_id=n_data.get(\"id\"))\n            \n            node.attachment_type = n_data.get(\"attachment_type\", \"None\")\n            node.custom_color = n_data.get(\"custom_color\")\n            node.is_completed = n_data.get(\"is_completed\", False)\n            node.is_start_node = n_data.get(\"is_start_node\", False) # Load start state\n            \n            node.check_status()\n            node.set_text_style(node.is_completed) \n            \n            self.scene.addItem(node)\n            self.nodes.append(node)\n            node_map[node.id] = node\n            \n        for e_data in data[\"edges\"]:\n            start = node_map.get(e_data[\"start\"])\n            end = node_map.get(e_data[\"end\"])\n            if start and end:\n                self.create_connection(start, end)\n        \n        if self.nodes:\n            self.focus_camera_on_nodes()\n        self.update_progress() \n\n    def change_pipeline(self, index):\n        self.save_current_pipeline_to_memory()\n        new_name = self.combo_pipelines.currentText()\n        self.current_pipeline_name = new_name\n        self.load_pipeline_to_scene(new_name)\n\n    def create_new_pipeline(self):\n        name, ok = QInputDialog.getText(self, \"New Project\", \"Project Name:\")\n        if ok and name:\n            if name in self.pipelines_data:\n                QMessageBox.warning(self, \"Error\", \"Project already exists!\")\n                return\n            \n            self.save_current_pipeline_to_memory()\n            self.pipelines_data[name] = {\"nodes\": [], \"edges\": []}\n            self.combo_pipelines.addItem(name)\n            self.combo_pipelines.setCurrentText(name) \n\n    # --- STANDARD FUNCTIONS ---\n    def add_node(self, name, x, y):\n        node = SmartNode(name, x, y, self)\n        self.scene.addItem(node)\n        self.nodes.append(node)\n        self.update_progress() # Update bar on add\n        return node\n\n    def add_new_node_center(self):\n        center = self.view.mapToScene(self.view.viewport().rect().center())\n        self.add_node(\"New Task\", center.x() - 100, center.y() - 40)\n\n    def connect_selected_nodes(self):\n        selected_items = self.scene.selectedItems()\n        selected_nodes = [item for item in selected_items if isinstance(item, SmartNode)]\n        if len(selected_nodes) == 2:\n            self.create_connection(selected_nodes[0], selected_nodes[1])\n\n    def create_connection(self, start_node, end_node):\n        line = ConnectionLine(start_node, end_node)\n        self.scene.addItem(line)\n        self.lines.append(line)\n        start_node.connected_lines.append(line)\n        end_node.connected_lines.append(line)\n\n    def update_all_nodes(self):\n        for node in self.nodes:\n            node.check_status()\n\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    window = SmartWorkflowOrganizer()\n    window.show()\n    sys.exit(app.exec())",
        "language": "Python"
    },
    "my_timer": {
        "content": "# Tool: my_timer\n# Description: Create a tool named my_timer that waits for 2 seconds\n\nimport os\nimport datetime\nimport random\nimport sys\nimport time\n\ndef run_task():\n    print(f'Task: Create a tool named my_timer that waits for 2 seconds')\n    print(f'CWD: {os.getcwd()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "calc_pi": {
        "content": "# Tool: calc_pi\n# Description: Create a tool named calc_pi that calculates pi.\n\nimport math\n\nprint(f'Square root of 16 is {math.sqrt(16)}')\nprint(f'2 to the power of 5 is {math.pow(2, 5)}')\n",
        "language": "Python"
    },
    "lucky_dice": {
        "content": "# Tool: lucky_dice\n# Description: Create a new tool named lucky_dice that rolls a random number\n\nimport random\n\nprint(f'Rolling dice: {random.randint(1, 6)}')\n",
        "language": "Python"
    },
    "auto_list_sorter_1770326212": {
        "content": "# Tool: auto_list_sorter_1770326212\n# Description: sort a list of numbers\n\ndef run_task():\n    print('Executing task: sort a list of numbers')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_timer_wait_1770326222": {
        "content": "# Tool: auto_timer_wait_1770326222\n# Description: wait for 1 second\n\nimport time\n\nprint('Timer started...')\ntime.sleep(2)\nprint('Timer finished!')\n",
        "language": "Python"
    },
    "auto_fibonacci_1770326234": {
        "content": "# Tool: auto_fibonacci_1770326234\n# Description: calculate the first 10 fibonacci numbers\n\nimport math\n\nprint(f'Square root of 16 is {math.sqrt(16)}')\nprint(f'2 to the power of 5 is {math.pow(2, 5)}')\n",
        "language": "Python"
    },
    "auto_timer_wait_1770326244": {
        "content": "# Tool: auto_timer_wait_1770326244\n# Description: wait for 1 second\n\nimport time\n\nprint('Timer started...')\ntime.sleep(2)\nprint('Timer finished!')\n",
        "language": "Python"
    },
    "auto_text_reverser_1770326256": {
        "content": "# Tool: auto_text_reverser_1770326256\n# Description: reverse a string text\n\ndef run_task():\n    print('Executing task: reverse a string text')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_prime_checker_1770326266": {
        "content": "# Tool: auto_prime_checker_1770326266\n# Description: check if a number is prime\n\ndef run_task():\n    print('Executing task: check if a number is prime')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_list_sorter_1770326276": {
        "content": "# Tool: auto_list_sorter_1770326276\n# Description: sort a list of numbers\n\ndef run_task():\n    print('Executing task: sort a list of numbers')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_fibonacci_1770326286": {
        "content": "# Tool: auto_fibonacci_1770326286\n# Description: calculate the first 10 fibonacci numbers\n\nimport math\n\nprint(f'Square root of 16 is {math.sqrt(16)}')\nprint(f'2 to the power of 5 is {math.pow(2, 5)}')\n",
        "language": "Python"
    },
    "auto_dict_merger_1770326296": {
        "content": "# Tool: auto_dict_merger_1770326296\n# Description: merge two dictionaries\n\ndef run_task():\n    print('Executing task: merge two dictionaries')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_prime_checker_1770326306": {
        "content": "# Tool: auto_prime_checker_1770326306\n# Description: check if a number is prime\n\ndef run_task():\n    print('Executing task: check if a number is prime')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_fibonacci_1770326316": {
        "content": "# Tool: auto_fibonacci_1770326316\n# Description: calculate the first 10 fibonacci numbers\n\nimport math\n\nprint(f'Square root of 16 is {math.sqrt(16)}')\nprint(f'2 to the power of 5 is {math.pow(2, 5)}')\n",
        "language": "Python"
    },
    "auto_file_logger_1770326326": {
        "content": "# Tool: auto_file_logger_1770326326\n# Description: write a log to a text file\n\nfilename = 'test_gen.txt'\nwith open(filename, 'w') as f:\n    f.write('Generated by Neural Brain.')\nprint(f'Wrote to {filename}')\n",
        "language": "Python"
    },
    "auto_text_reverser_1770326336": {
        "content": "# Tool: auto_text_reverser_1770326336\n# Description: reverse a string text\n\ndef run_task():\n    print('Executing task: reverse a string text')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_dict_merger_1770326346": {
        "content": "# Tool: auto_dict_merger_1770326346\n# Description: merge two dictionaries\n\ndef run_task():\n    print('Executing task: merge two dictionaries')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_timer_wait_1770326356": {
        "content": "# Tool: auto_timer_wait_1770326356\n# Description: wait for 1 second\n\nimport time\n\nprint('Timer started...')\ntime.sleep(2)\nprint('Timer finished!')\n",
        "language": "Python"
    },
    "auto_file_logger_1770326368": {
        "content": "# Tool: auto_file_logger_1770326368\n# Description: write a log to a text file\n\nfilename = 'test_gen.txt'\nwith open(filename, 'w') as f:\n    f.write('Generated by Neural Brain.')\nprint(f'Wrote to {filename}')\n",
        "language": "Python"
    },
    "auto_timer_wait_1770326378": {
        "content": "# Tool: auto_timer_wait_1770326378\n# Description: wait for 1 second\n\nimport time\n\nprint('Timer started...')\ntime.sleep(2)\nprint('Timer finished!')\n",
        "language": "Python"
    },
    "auto_list_sorter_1770326390": {
        "content": "# Tool: auto_list_sorter_1770326390\n# Description: sort a list of numbers\n\ndef run_task():\n    print('Executing task: sort a list of numbers')\n    print('Task complete.')\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_dates_1770326758": {
        "content": "# Tool: auto_analyze_dates_1770326758\n# Description: analyze dates\n\nimport datetime\nimport time\n\ndef run_task():\n    now = datetime.datetime.now()\n    print(f'Current System Time: {now}')\n    future = now + datetime.timedelta(days=100)\n    print(f'Date in 100 days: {future}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_json_data_1770326768": {
        "content": "# Tool: auto_sort_json_data_1770326768\n# Description: sort json data\n\nimport json\nimport time\n\ndef run_task():\n    data = {'name': 'Genesis', 'status': 'Online', 'timestamp': str(datetime.datetime.now())}\n    json_str = json.dumps(data, indent=4)\n    print('Generated JSON:')\n    print(json_str)\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generate_dates_1770326778": {
        "content": "# Tool: auto_generate_dates_1770326778\n# Description: generate dates\n\nimport datetime\nimport time\n\ndef run_task():\n    now = datetime.datetime.now()\n    print(f'Current System Time: {now}')\n    future = now + datetime.timedelta(days=100)\n    print(f'Date in 100 days: {future}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_json_data_1770326788": {
        "content": "# Tool: auto_parse_json_data_1770326788\n# Description: parse json data\n\nimport json\nimport time\n\ndef run_task():\n    data = {'name': 'Genesis', 'status': 'Online', 'timestamp': str(datetime.datetime.now())}\n    json_str = json.dumps(data, indent=4)\n    print('Generated JSON:')\n    print(json_str)\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_prime_numbers_1770326798": {
        "content": "# Tool: auto_analyze_prime_numbers_1770326798\n# Description: analyze prime numbers\n\nimport time\n\ndef is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0: return False\n    return True\n\ndef run_task():\n    num = random.randint(10, 100)\n    print(f'Checking if {num} is prime: {is_prime(num)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_file_logs_1770326808": {
        "content": "# Tool: auto_sort_file_logs_1770326808\n# Description: sort file logs\n\nimport time\n\ndef run_task():\n    print('Executing generic task: sort file logs')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generate_random_dice_1770326818": {
        "content": "# Tool: auto_generate_random_dice_1770326818\n# Description: generate random dice\n\nimport random\nimport time\n\ndef run_task():\n    print(f'Rolling d20: {random.randint(1, 20)}')\n    opts = ['Yes', 'No', 'Maybe', 'Try Again']\n    print(f'Magic 8-Ball says: {random.choice(opts)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_random_dice_1770326828": {
        "content": "# Tool: auto_calculate_random_dice_1770326828\n# Description: calculate random dice\n\nimport math\nimport random\nimport time\n\ndef run_task():\n    print(f'Rolling d20: {random.randint(1, 20)}')\n    opts = ['Yes', 'No', 'Maybe', 'Try Again']\n    print(f'Magic 8-Ball says: {random.choice(opts)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_json_data_1770326838": {
        "content": "# Tool: auto_calculate_json_data_1770326838\n# Description: calculate json data\n\nimport json\nimport math\nimport time\n\ndef run_task():\n    data = {'name': 'Genesis', 'status': 'Online', 'timestamp': str(datetime.datetime.now())}\n    json_str = json.dumps(data, indent=4)\n    print('Generated JSON:')\n    print(json_str)\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_list_of_numbers_1770326848": {
        "content": "# Tool: auto_parse_list_of_numbers_1770326848\n# Description: parse list of numbers\n\nimport time\n\ndef run_task():\n    print('Executing generic task: parse list of numbers')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generate_prime_numbers_1770326858": {
        "content": "# Tool: auto_generate_prime_numbers_1770326858\n# Description: generate prime numbers\n\nimport time\n\ndef is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0: return False\n    return True\n\ndef run_task():\n    num = random.randint(10, 100)\n    print(f'Checking if {num} is prime: {is_prime(num)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_dates_1770326868": {
        "content": "# Tool: auto_sort_dates_1770326868\n# Description: sort dates\n\nimport datetime\nimport time\n\ndef run_task():\n    now = datetime.datetime.now()\n    print(f'Current System Time: {now}')\n    future = now + datetime.timedelta(days=100)\n    print(f'Date in 100 days: {future}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_random_dice_1770326878": {
        "content": "# Tool: auto_parse_random_dice_1770326878\n# Description: parse random dice\n\nimport random\nimport time\n\ndef run_task():\n    print(f'Rolling d20: {random.randint(1, 20)}')\n    opts = ['Yes', 'No', 'Maybe', 'Try Again']\n    print(f'Magic 8-Ball says: {random.choice(opts)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_json_data_1770326888": {
        "content": "# Tool: auto_analyze_json_data_1770326888\n# Description: analyze json data\n\nimport json\nimport time\n\ndef run_task():\n    data = {'name': 'Genesis', 'status': 'Online', 'timestamp': str(datetime.datetime.now())}\n    json_str = json.dumps(data, indent=4)\n    print('Generated JSON:')\n    print(json_str)\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_file_logs_1770326898": {
        "content": "# Tool: auto_analyze_file_logs_1770326898\n# Description: analyze file logs\n\nimport time\n\ndef run_task():\n    print('Executing generic task: analyze file logs')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_file_logs_1770326908": {
        "content": "# Tool: auto_calculate_file_logs_1770326908\n# Description: calculate file logs\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: calculate file logs')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_dates_1770326918": {
        "content": "# Tool: auto_calculate_dates_1770326918\n# Description: calculate dates\n\nimport datetime\nimport math\nimport time\n\ndef run_task():\n    now = datetime.datetime.now()\n    print(f'Current System Time: {now}')\n    future = now + datetime.timedelta(days=100)\n    print(f'Date in 100 days: {future}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_prime_numbers_1770326928": {
        "content": "# Tool: auto_sort_prime_numbers_1770326928\n# Description: sort prime numbers\n\nimport time\n\ndef is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0: return False\n    return True\n\ndef run_task():\n    num = random.randint(10, 100)\n    print(f'Checking if {num} is prime: {is_prime(num)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generate_list_of_numbers_1770326938": {
        "content": "# Tool: auto_generate_list_of_numbers_1770326938\n# Description: generate list of numbers\n\nimport time\n\ndef run_task():\n    print('Executing generic task: generate list of numbers')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_dates_1770326948": {
        "content": "# Tool: auto_parse_dates_1770326948\n# Description: parse dates\n\nimport datetime\nimport time\n\ndef run_task():\n    now = datetime.datetime.now()\n    print(f'Current System Time: {now}')\n    future = now + datetime.timedelta(days=100)\n    print(f'Date in 100 days: {future}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_list_of_numbers_1770326958": {
        "content": "# Tool: auto_sort_list_of_numbers_1770326958\n# Description: sort list of numbers\n\nimport time\n\ndef run_task():\n    data = [random.randint(1, 100) for _ in range(10)]\n    print(f'Original: {data}')\n    sorted_data = sorted(data)\n    print(f'Sorted:   {sorted_data}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_list_of_numbers_1770326968": {
        "content": "# Tool: auto_calculate_list_of_numbers_1770326968\n# Description: calculate list of numbers\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: calculate list of numbers')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_file_logs_1770326978": {
        "content": "# Tool: auto_parse_file_logs_1770326978\n# Description: parse file logs\n\nimport time\n\ndef run_task():\n    print('Executing generic task: parse file logs')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_random_dice_1770326989": {
        "content": "# Tool: auto_sort_random_dice_1770326989\n# Description: sort random dice\n\nimport random\nimport time\n\ndef run_task():\n    print(f'Rolling d20: {random.randint(1, 20)}')\n    opts = ['Yes', 'No', 'Maybe', 'Try Again']\n    print(f'Magic 8-Ball says: {random.choice(opts)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_list_of_numbers_1770326999": {
        "content": "# Tool: auto_analyze_list_of_numbers_1770326999\n# Description: analyze list of numbers\n\nimport time\n\ndef run_task():\n    print('Executing generic task: analyze list of numbers')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_prime_numbers_1770327009": {
        "content": "# Tool: auto_parse_prime_numbers_1770327009\n# Description: parse prime numbers\n\nimport time\n\ndef is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0: return False\n    return True\n\ndef run_task():\n    num = random.randint(10, 100)\n    print(f'Checking if {num} is prime: {is_prime(num)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generate_file_logs_1770327019": {
        "content": "# Tool: auto_generate_file_logs_1770327019\n# Description: generate file logs\n\nimport time\n\ndef run_task():\n    print('Executing generic task: generate file logs')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_prime_numbers_1770327029": {
        "content": "# Tool: auto_calculate_prime_numbers_1770327029\n# Description: calculate prime numbers\n\nimport math\nimport time\n\ndef is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0: return False\n    return True\n\ndef run_task():\n    num = random.randint(10, 100)\n    print(f'Checking if {num} is prime: {is_prime(num)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generate_json_data_1770327039": {
        "content": "# Tool: auto_generate_json_data_1770327039\n# Description: generate json data\n\nimport json\nimport time\n\ndef run_task():\n    data = {'name': 'Genesis', 'status': 'Online', 'timestamp': str(datetime.datetime.now())}\n    json_str = json.dumps(data, indent=4)\n    print('Generated JSON:')\n    print(json_str)\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327049": {
        "content": "# Tool: auto_generic_task_1770327049\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_random_dice_1770327059": {
        "content": "# Tool: auto_analyze_random_dice_1770327059\n# Description: analyze random dice\n\nimport random\nimport time\n\ndef run_task():\n    print(f'Rolling d20: {random.randint(1, 20)}')\n    opts = ['Yes', 'No', 'Maybe', 'Try Again']\n    print(f'Magic 8-Ball says: {random.choice(opts)}')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327069": {
        "content": "# Tool: auto_generic_task_1770327069\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327079": {
        "content": "# Tool: auto_generic_task_1770327079\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327089": {
        "content": "# Tool: auto_generic_task_1770327089\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327099": {
        "content": "# Tool: auto_generic_task_1770327099\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327109": {
        "content": "# Tool: auto_generic_task_1770327109\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327119": {
        "content": "# Tool: auto_generic_task_1770327119\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327129": {
        "content": "# Tool: auto_generic_task_1770327129\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327139": {
        "content": "# Tool: auto_generic_task_1770327139\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327149": {
        "content": "# Tool: auto_generic_task_1770327149\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327159": {
        "content": "# Tool: auto_generic_task_1770327159\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327169": {
        "content": "# Tool: auto_generic_task_1770327169\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327179": {
        "content": "# Tool: auto_generic_task_1770327179\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generic_task_1770327189": {
        "content": "# Tool: auto_generic_task_1770327189\n# Description: perform a generic calculation\n\nimport math\nimport time\n\ndef run_task():\n    print('Executing generic task: perform a generic calculation')\n    print('Review logic required for specific implementation.')\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_prime_numbers_1770327518": {
        "content": "# Tool: auto_sort_prime_numbers_1770327518\n# Description: sort prime numbers\n\nimport math\nimport time\n\ndef run_task():\n    print('Initializing generic task...')\n    result = sorted(data)\n    print(f'Sorted: {result}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_dates_1770327528": {
        "content": "# Tool: auto_analyze_dates_1770327528\n# Description: analyze dates\n\nimport datetime\nimport time\n\ndef run_task():\n    now = datetime.datetime.now()\n    print('Analysis complete.')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_prime_numbers_1770327548": {
        "content": "# Tool: auto_analyze_prime_numbers_1770327548\n# Description: analyze prime numbers\n\nimport math\nimport time\n\ndef run_task():\n    print('Initializing generic task...')\n    print('Analysis complete.')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_random_dice_1770327558": {
        "content": "# Tool: auto_calculate_random_dice_1770327558\n# Description: calculate random dice\n\nimport random\nimport math\nimport time\n\ndef run_task():\n    rolls = [random.randint(1, 6) for _ in range(5)]\n    print(f'Rolled: {rolls}')\n    total = sum(data if 'list' in locals() else rolls)\n    print(f'Sum: {total}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_random_dice_1770327568": {
        "content": "# Tool: auto_analyze_random_dice_1770327568\n# Description: analyze random dice\n\nimport random\nimport time\n\ndef run_task():\n    rolls = [random.randint(1, 6) for _ in range(5)]\n    print(f'Rolled: {rolls}')\n    total = sum(data if 'list' in locals() else rolls)\n    print(f'Sum: {total}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_sort_random_dice_1770327578": {
        "content": "# Tool: auto_sort_random_dice_1770327578\n# Description: sort random dice\n\nimport random\nimport time\n\ndef run_task():\n    rolls = [random.randint(1, 6) for _ in range(5)]\n    print(f'Rolled: {rolls}')\n    result = sorted(data)\n    print(f'Sorted: {result}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_file_logs_1770327588": {
        "content": "# Tool: auto_analyze_file_logs_1770327588\n# Description: analyze file logs\n\nimport time\n\ndef run_task():\n    print('Initializing generic task...')\n    print('Analysis complete.')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_json_data_1770327598": {
        "content": "# Tool: auto_calculate_json_data_1770327598\n# Description: calculate json data\n\nimport math\nimport time\nimport json\n\ndef run_task():\n    data = {'id': 1, 'status': 'active', 'values': [10, 20, 30]}\n    print('Analysis complete.')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_analyze_list_of_numbers_1770327608": {
        "content": "# Tool: auto_analyze_list_of_numbers_1770327608\n# Description: analyze list of numbers\n\nimport random\nimport time\n\ndef run_task():\n    data = [random.randint(1, 100) for _ in range(10)]\n    print(f'Original Data: {data}')\n    total = sum(data if 'list' in locals() else rolls)\n    print(f'Sum: {total}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_file_logs_1770327618": {
        "content": "# Tool: auto_parse_file_logs_1770327618\n# Description: parse file logs\n\nimport time\n\ndef run_task():\n    print('Initializing generic task...')\n    print('Operation completed.')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_parse_json_data_1770327628": {
        "content": "# Tool: auto_parse_json_data_1770327628\n# Description: parse json data\n\nimport time\nimport json\n\ndef run_task():\n    data = {'id': 1, 'status': 'active', 'values': [10, 20, 30]}\n    json_str = json.dumps(data)\n    parsed = json.loads(json_str)\n    print(f'Parsed JSON keys: {list(parsed.keys())}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_list_of_numbers_1770327638": {
        "content": "# Tool: auto_calculate_list_of_numbers_1770327638\n# Description: calculate list of numbers\n\nimport random\nimport math\nimport time\n\ndef run_task():\n    data = [random.randint(1, 100) for _ in range(10)]\n    print(f'Original Data: {data}')\n    total = sum(data if 'list' in locals() else rolls)\n    print(f'Sum: {total}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_generate_prime_numbers_1770327648": {
        "content": "# Tool: auto_generate_prime_numbers_1770327648\n# Description: generate prime numbers\n\nimport math\nimport time\n\ndef run_task():\n    print('Initializing generic task...')\n    primes = [x for x in range(2, 50) if all(x % i != 0 for i in range(2, int(math.sqrt(x))+1))]\n    print(f'Primes < 50: {primes}')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_prime_numbers_1770327658": {
        "content": "# Tool: auto_calculate_prime_numbers_1770327658\n# Description: calculate prime numbers\n\nimport math\nimport time\n\ndef run_task():\n    print('Initializing generic task...')\n    print('Analysis complete.')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_calculate_dates_1770327668": {
        "content": "# Tool: auto_calculate_dates_1770327668\n# Description: calculate dates\n\nimport datetime\nimport time\nimport math\n\ndef run_task():\n    now = datetime.datetime.now()\n    print('Analysis complete.')\n\n\nif __name__ == '__main__':\n    run_task()\n",
        "language": "Python"
    },
    "auto_find_todos_1770329293": {
        "content": "# Tool: auto_find_todos_1770329293\n# Description: find TODO comments in project\n\nimport time\nimport sys\nimport os\nimport re\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_1770329313": {
        "content": "# Tool: auto_map_directory_1770329313\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770329324": {
        "content": "# Tool: auto_map_directory_v2_1770329324\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770329334": {
        "content": "# Tool: auto_map_directory_v2_1770329334\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_1770329344": {
        "content": "# Tool: auto_analyze_code_1770329344\n# Description: analyze code structure of ai_brain.py\n\nimport time\nimport sys\nimport ast\nimport os\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_sort_numbers_1770329354": {
        "content": "# Tool: auto_sort_numbers_1770329354\n# Description: sort a list of random numbers\n\nimport time\nimport sys\nimport random\nimport os\n\ndef run_task():\n    print(f'Task: sort a list of random numbers')\n    print(f'CWD: {os.getcwd()}')\n    data = [random.randint(1, 100) for _ in range(10)]\n    print(f'Original: {data}')\n    sorted_data = sorted(data)\n    print(f'Sorted:   {sorted_data}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770329369": {
        "content": "# Tool: auto_map_directory_v2_1770329369\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_v2_1770329384": {
        "content": "# Tool: auto_analyze_code_v2_1770329384\n# Description: analyze code structure of ai_brain.py\n\nimport time\nimport sys\nimport ast\nimport os\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_v2_1770329394": {
        "content": "# Tool: auto_analyze_code_v2_1770329394\n# Description: analyze code structure of ai_brain.py\n\nimport time\nimport sys\nimport ast\nimport os\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_sort_numbers_v2_1770329419": {
        "content": "# Tool: auto_sort_numbers_v2_1770329419\n# Description: sort a list of random numbers\n\nimport time\nimport sys\nimport random\nimport os\n\ndef run_task():\n    print(f'Task: sort a list of random numbers')\n    print(f'CWD: {os.getcwd()}')\n    data = [random.randint(1, 100) for _ in range(10)]\n    print(f'Original: {data}')\n    sorted_data = sorted(data)\n    print(f'Sorted:   {sorted_data}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770329429": {
        "content": "# Tool: auto_map_directory_v2_1770329429\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_v2_1770329444": {
        "content": "# Tool: auto_find_todos_v2_1770329444\n# Description: find TODO comments in project\n\nimport time\nimport sys\nimport os\nimport re\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770329454": {
        "content": "# Tool: auto_map_directory_v2_1770329454\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_v2_1770329464": {
        "content": "# Tool: auto_find_todos_v2_1770329464\n# Description: find TODO comments in project\n\nimport time\nimport sys\nimport os\nimport re\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770329474": {
        "content": "# Tool: auto_map_directory_v2_1770329474\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770329484": {
        "content": "# Tool: auto_map_directory_v2_1770329484\n# Description: map directory structure\n\nimport time\nimport sys\nimport os\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_v2_1770329499": {
        "content": "# Tool: auto_analyze_code_v2_1770329499\n# Description: analyze code structure of ai_brain.py\n\nimport time\nimport sys\nimport ast\nimport os\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_v2_1770329519": {
        "content": "# Tool: auto_analyze_code_v2_1770329519\n# Description: analyze code structure of ai_brain.py\n\nimport time\nimport sys\nimport ast\nimport os\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_v2_1770329529": {
        "content": "# Tool: auto_analyze_code_v2_1770329529\n# Description: analyze code structure of ai_brain.py\n\nimport time\nimport sys\nimport ast\nimport os\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_v2_1770329539": {
        "content": "# Tool: auto_analyze_code_v2_1770329539\n# Description: analyze code structure of ai_brain.py\n\nimport time\nimport sys\nimport ast\nimport os\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_v2_1770329550": {
        "content": "# Tool: auto_find_todos_v2_1770329550\n# Description: find TODO comments in project\n\nimport time\nimport sys\nimport os\nimport re\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_v2_1770329560": {
        "content": "# Tool: auto_find_todos_v2_1770329560\n# Description: find TODO comments in project\n\nimport time\nimport sys\nimport os\nimport re\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_1770330296": {
        "content": "# Tool: auto_find_todos_1770330296\n# Description: find TODO comments in project\n\nimport sys\nimport os\nimport re\nimport time\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_v2_1770330311": {
        "content": "# Tool: auto_find_todos_v2_1770330311\n# Description: find TODO comments in project\n\nimport sys\nimport os\nimport re\nimport time\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_json_1770330321": {
        "content": "# Tool: auto_find_todos_json_1770330321\n# Description: find TODO comments and save to json report\n\nimport os\nimport time\nimport re\nimport sys\nimport json\n\ndef run_task():\n    print(f'Task: find TODO comments and save to json report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs (JSON Mode)...')\n    todos = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            todos.append({'file': file, 'line': i, 'content': line.strip()})\n    print(json.dumps(todos, indent=2))\n    with open('todo_report.json', 'w') as f: json.dump(todos, f, indent=2)\n    print('Report saved to todo_report.json')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_1770330331": {
        "content": "# Tool: auto_map_directory_1770330331\n# Description: map directory structure\n\nimport sys\nimport os\nimport time\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_depth_1770330341": {
        "content": "# Tool: auto_map_directory_depth_1770330341\n# Description: map directory structure with depth and classes\n\nimport sys\nimport os\nimport time\n\ndef run_task():\n    print(f'Task: map directory structure with depth and classes')\n    print(f'CWD: {os.getcwd()}')\n    print('Deep Project Map (Files + Classes):')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        print(f'{root}/')\n        for f in files:\n            if f.endswith('.py'):\n                path = os.path.join(root, f)\n                classes = []\n                try:\n                    with open(path, 'r') as pf: classes = [l.split()[1].split('(')[0] for l in pf if l.startswith('class ')]\n                except: pass\n                print(f'  - {f} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_1770330351": {
        "content": "# Tool: auto_analyze_code_1770330351\n# Description: analyze code structure of ai_brain.py\n\nimport sys\nimport os\nimport ast\nimport time\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_complexity_1770330361": {
        "content": "# Tool: auto_analyze_code_complexity_1770330361\n# Description: analyze code structure complexity and size\n\nimport sys\nimport os\nimport ast\nimport time\n\ndef run_task():\n    print(f'Task: analyze code structure complexity and size')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770330371": {
        "content": "# Tool: auto_map_directory_v2_1770330371\n# Description: map directory structure\n\nimport sys\nimport os\nimport time\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_map_directory_v2_1770330381": {
        "content": "# Tool: auto_map_directory_v2_1770330381\n# Description: map directory structure\n\nimport sys\nimport os\nimport time\n\ndef run_task():\n    print(f'Task: map directory structure')\n    print(f'CWD: {os.getcwd()}')\n    print('Project Structure:')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        level = root.replace('.', '').count(os.sep)\n        indent = ' ' * 4 * (level)\n        print(f'{indent}{os.path.basename(root)}/')\n        subindent = ' ' * 4 * (level + 1)\n        for f in files:\n            if f.endswith('.py'):\n                 print(f'{subindent}{f}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_sort_numbers_1770330391": {
        "content": "# Tool: auto_sort_numbers_1770330391\n# Description: sort a list of random numbers\n\nimport sys\nimport os\nimport random\nimport time\n\ndef run_task():\n    print(f'Task: sort a list of random numbers')\n    print(f'CWD: {os.getcwd()}')\n    data = [random.randint(1, 100) for _ in range(10)]\n    print(f'Original: {data}')\n    sorted_data = sorted(data)\n    print(f'Sorted:   {sorted_data}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_find_todos_v2_1770330401": {
        "content": "# Tool: auto_find_todos_v2_1770330401\n# Description: find TODO comments in project\n\nimport sys\nimport os\nimport re\nimport time\n\ndef run_task():\n    print(f'Task: find TODO comments in project')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project for TODOs...')\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                path = os.path.join(root, file)\n                with open(path, 'r', encoding='utf-8') as f:\n                    for i, line in enumerate(f, 1):\n                        if 'TODO' in line:\n                            print(f'{file}:{i} -> {line.strip()}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_analyze_code_v2_1770330411": {
        "content": "# Tool: auto_analyze_code_v2_1770330411\n# Description: analyze code structure of ai_brain.py\n\nimport sys\nimport os\nimport ast\nimport time\n\ndef run_task():\n    print(f'Task: analyze code structure of ai_brain.py')\n    print(f'CWD: {os.getcwd()}')\n    target = 'ai_brain.py'\n    if not os.path.exists(target):\n        print(f'Missing: Target {target} not found.')\n        return\n    with open(target, 'r', encoding='utf-8') as f: content = f.read()\n    tree = ast.parse(content)\n    functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n    print(f'Analysis of {target}:')\n    print(f'  Functions: {len(functions)} {functions}')\n    print(f'  Classes:   {len(classes)} {classes}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_count_classes_10_1770331421": {
        "content": "# Tool: auto_procedural_count_classes_10_1770331421\n# Description: count classes in project and save to json\n\nimport datetime\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: count classes in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_TODO_59_1770331431": {
        "content": "# Tool: auto_procedural_find_TODO_59_1770331431\n# Description: find TODO in project and save to json\n\nimport re\nimport datetime\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: find TODO in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_count_lines_1770331442": {
        "content": "# Tool: auto_count_lines_1770331442\n# Description: count lines in script_library.py\n\nimport datetime\nimport random\nimport sys\nimport time\nimport os\n\ndef run_task():\n    print(f'Task: count lines in script_library.py')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    total_lines = 0\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                lines = len(f.readlines())\n                total_lines += lines\n                print(f'{path}: {lines}')\n        except: pass\n    print(f'Total Lines: {total_lines}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_functions_96_1770331462": {
        "content": "# Tool: auto_procedural_analyze_functions_96_1770331462\n# Description: analyze functions recursively and report\n\nimport datetime\nimport ast\nimport random\nimport sys\nimport time\nimport os\n\ndef run_task():\n    print(f'Task: analyze functions recursively and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_classes_68_1770331472": {
        "content": "# Tool: auto_procedural_analyze_classes_68_1770331472\n# Description: analyze classes recursively and report\n\nimport datetime\nimport ast\nimport random\nimport sys\nimport time\nimport os\n\ndef run_task():\n    print(f'Task: analyze classes recursively and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_count_TODO_55_1770331482": {
        "content": "# Tool: auto_procedural_count_TODO_55_1770331482\n# Description: count TODO in project and report\n\nimport datetime\nimport random\nimport sys\nimport time\nimport os\n\ndef run_task():\n    print(f'Task: count TODO in project and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_classes_50_1770331497": {
        "content": "# Tool: auto_procedural_find_classes_50_1770331497\n# Description: find classes in project and save to json\n\nimport re\nimport datetime\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: find classes in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_classes_75_1770331507": {
        "content": "# Tool: auto_procedural_analyze_classes_75_1770331507\n# Description: analyze classes recursively and save to json\n\nimport datetime\nimport ast\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: analyze classes recursively and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_TODO_80_1770331517": {
        "content": "# Tool: auto_procedural_find_TODO_80_1770331517\n# Description: find TODO in project and report\n\nimport re\nimport datetime\nimport random\nimport sys\nimport time\nimport os\n\ndef run_task():\n    print(f'Task: find TODO in project and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_classes_19_1770331527": {
        "content": "# Tool: auto_procedural_find_classes_19_1770331527\n# Description: find classes in project and save to json\n\nimport re\nimport datetime\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: find classes in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_functions_3_1770331543": {
        "content": "# Tool: auto_procedural_analyze_functions_3_1770331543\n# Description: analyze functions recursively and save to json\n\nimport datetime\nimport ast\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: analyze functions recursively and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_functions_51_1770331563": {
        "content": "# Tool: auto_procedural_find_functions_51_1770331563\n# Description: find functions in project and save to json\n\nimport re\nimport datetime\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: find functions in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_count_TODO_48_1770331573": {
        "content": "# Tool: auto_procedural_count_TODO_48_1770331573\n# Description: count TODO in project and save to json\n\nimport datetime\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: count TODO in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_classes_62_1770331588": {
        "content": "# Tool: auto_procedural_find_classes_62_1770331588\n# Description: find classes in project and save to json\n\nimport re\nimport datetime\nimport random\nimport sys\nimport time\nimport os\nimport json\n\ndef run_task():\n    print(f'Task: find classes in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_count_classes_59_1770332165": {
        "content": "# Tool: auto_procedural_count_classes_59_1770332165\n# Description: count classes recursively and save to json\n\nimport datetime\nimport time\nimport os\nimport sys\nimport json\nimport random\n\ndef run_task():\n    print(f'Task: count classes recursively and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_functions_42_1770332175": {
        "content": "# Tool: auto_procedural_analyze_functions_42_1770332175\n# Description: analyze functions recursively and save to json\n\nimport datetime\nimport ast\nimport time\nimport os\nimport sys\nimport json\nimport random\n\ndef run_task():\n    print(f'Task: analyze functions recursively and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_classes_26_1770332185": {
        "content": "# Tool: auto_procedural_find_classes_26_1770332185\n# Description: find classes recursively and save to json\n\nimport datetime\nimport re\nimport time\nimport os\nimport sys\nimport json\nimport random\n\ndef run_task():\n    print(f'Task: find classes recursively and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_TODO_97_1770332200": {
        "content": "# Tool: auto_procedural_analyze_TODO_97_1770332200\n# Description: analyze TODO in project and report\n\nimport datetime\nimport ast\nimport time\nimport os\nimport sys\nimport random\n\ndef run_task():\n    print(f'Task: analyze TODO in project and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_TODO_6_1770332210": {
        "content": "# Tool: auto_procedural_find_TODO_6_1770332210\n# Description: find TODO recursively and save to json\n\nimport datetime\nimport re\nimport time\nimport os\nimport sys\nimport json\nimport random\n\ndef run_task():\n    print(f'Task: find TODO recursively and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_research_basics_1770332225": {
        "content": "# Tool: auto_research_basics_1770332225\n# Description: research common language phrases\n\nimport datetime\nimport time\nimport os\nimport sys\nimport random\n\ndef run_task():\n    print(f'Task: research common language phrases')\n    print(f'CWD: {os.getcwd()}')\n    # Knowledge Acquisition\n    from ai_brain import KnowledgeSeeker\n    print(KnowledgeSeeker.research_topic('common language phrases'))\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_classes_26_1770332240": {
        "content": "# Tool: auto_procedural_analyze_classes_26_1770332240\n# Description: analyze classes in project and save to json\n\nimport datetime\nimport ast\nimport time\nimport os\nimport sys\nimport json\nimport random\n\ndef run_task():\n    print(f'Task: analyze classes in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_count_TODO_36_1770332255": {
        "content": "# Tool: auto_procedural_count_TODO_36_1770332255\n# Description: count TODO recursively and report\n\nimport datetime\nimport time\nimport os\nimport sys\nimport random\n\ndef run_task():\n    print(f'Task: count TODO recursively and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_count_classes_28_1770332270": {
        "content": "# Tool: auto_procedural_count_classes_28_1770332270\n# Description: count classes in project and save to json\n\nimport datetime\nimport time\nimport os\nimport sys\nimport json\nimport random\n\ndef run_task():\n    print(f'Task: count classes in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_TODO_99_1770332296": {
        "content": "# Tool: auto_procedural_find_TODO_99_1770332296\n# Description: find TODO in project and save to json\n\nimport datetime\nimport re\nimport time\nimport os\nimport sys\nimport json\nimport random\n\ndef run_task():\n    print(f'Task: find TODO in project and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_find_TODO_1770332930": {
        "content": "# Tool: auto_procedural_find_TODO_1770332930\n# Description: find TODO in project and report\n\nimport random\nimport sys\nimport time\nimport re\nimport os\nimport datetime\n\ndef run_task():\n    print(f'Task: find TODO in project and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_count_TODO_1770332940": {
        "content": "# Tool: auto_procedural_count_TODO_1770332940\n# Description: count TODO in project and report\n\nimport random\nimport sys\nimport time\nimport os\nimport datetime\n\ndef run_task():\n    print(f'Task: count TODO in project and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_classes_1770332970": {
        "content": "# Tool: auto_procedural_analyze_classes_1770332970\n# Description: analyze classes recursively and report\n\nimport random\nimport sys\nimport time\nimport ast\nimport os\nimport datetime\n\ndef run_task():\n    print(f'Task: analyze classes recursively and report')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    all_funcs = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f: content = f.read()\n            tree = ast.parse(content)\n            funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n            if funcs:\n                print(f'{path}: {funcs}')\n                all_funcs.extend(funcs)\n        except: pass\n    print(f'Total Functions Found: {len(all_funcs)}')\n\n\nrun_task()\n",
        "language": "Python"
    },
    "auto_procedural_analyze_TODO_1770333025": {
        "content": "# Tool: auto_procedural_analyze_TODO_1770333025\n# Description: analyze TODO recursively and save to json\n\nimport random\nimport sys\nimport time\nimport ast\nimport json\nimport os\nimport datetime\n\ndef run_task():\n    print(f'Task: analyze TODO recursively and save to json')\n    print(f'CWD: {os.getcwd()}')\n    print('Scanning project...')\n    target_files = []\n    for root, dirs, files in os.walk('.'):\n        if '.venv' in root or '.git' in root: continue\n        for file in files:\n            if file.endswith('.py'):\n                target_files.append(os.path.join(root, file))\n    found_items = []\n    for path in target_files:\n        try:\n            with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n                for i, line in enumerate(f, 1):\n                    if 'TODO' in line:\n                        item = {'file': path, 'line': i, 'content': line.strip()}\n                        found_items.append(item)\n                        print(f'{path}:{i} -> {line.strip()}')\n        except: pass\n    # Saving Report\n    report_data = []\n    if 'found_items' in locals(): report_data = found_items\n    elif 'all_funcs' in locals(): report_data = all_funcs\n    elif 'target_files' in locals(): report_data = target_files\n    \n    filename = 'auto_report.json'\n    with open(filename, 'w') as f: json.dump(report_data, f, indent=2)\n    print(f'Report saved to {filename}')\n\n\nrun_task()\n",
        "language": "Python"
    }
}